# AI-Solver-for-Peg-Solitaire-Graph-Search
In this programming AI algorithm is built to solve Peg Solitaire (known as Brain Vita in India).  The game was invented in the XVII century in Madagascar. The first reference to the rules appeared in 1687 in a French cultural magazine. It is one of the classic boardgame puzzles, and several boards that differ in shape and size appeared through time.

##The Peg Solitaire game
As explained in the Wikipedia entry, The player can move a peg jumping on top of another adjacent peg, if there is a free adjacent cell to land.  There are 4 valid jumps:  Left, Right, Up and Down. The objective is to clean the board until there is only 1 peg left.  Some variants require that the last remaining peg sits on the middle of the board.  In this game we ignore that variant and win the game if only 1 peg is left, no matter its final position.  An AI agent or human player can choose the sequence of jumps to win the game. Solving Pegsol belongs to the class of problems known as NP-Complete problems (paper).   NP-complete problems are hard to solve. The best algorithms to solve NP-Complete problems run in exponential time as a function of the size of the problem. 

##Human Player Mode
In the code provided, we can move the cursor in four directions using the arrow keys: up, down, left, and right.  Use the enter/return key to select (or deselect) a peg. Pegs can then be moved using the arrow keys.  Quit, restart and undo keys are ’q’, ’r’ and ’u’. A peg can only move if it can jump over an adjacent peg and land on an empty space. A peg is represented by a circle and a empty space by dot.  You win the game when you end with one peg (anywhere in the board).  When there are no more moves possible the game is over.

Each possible configuration of the Peg Solitaire (Pegsol) is a tuple made of m × m grid board, the position of the cursor and whether the peg under the cursor has been selected. This tuple is called a state. The Pegsol Graph G = hV, Ei is implicitly defined. The vertex set V is defined as all the possible configurations (states), and the edges E connecting two vertexes are defined by the legal jump actions (right, left, up, down). Our task is to find the path leading to the best solution, i.e., leading to the vertex (state) with the least number of remaining pegs. A path is a sequence of actions. We are going to use Depth First Search to find the best solution, up to a maximum budget of expanded/explored nodes (nodes for which we have generated its children). When the AI solver is called (Algorithm 1), it should explore all possible paths (sequence of jump actions) following a Depth First Search (DFS) strategy, until consuming the budget or until a path solving the game is found. Note that we do not include duplicate states in the search. If a state was already generated, we will not include it again in the stack (line 21). The algorithm should return the best solution found, the path leading to the least number of remaining pegs. This path will then be executed by the game engine. We might have multiple paths leading to a solution. The algorithm will consider the possible action by scanning the board in this order: traverse coordinate x = 0, . . ., m first, and then y = 0, . . ., m looking for a peg that can jump, and then selecting jumping actions left, right, up or down. 
